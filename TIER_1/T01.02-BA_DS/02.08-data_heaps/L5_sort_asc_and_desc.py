

# У цьому коді, залежно від того, чи параметр descending встановлено в True чи False, 
# змінна sign приймає значення -1 або 1 відповідно. 
# При вставці значень у купу вони помножуються на sign, що забезпечує потрібний порядок сортування. 
# При витягуванні елементів з купи їхні значення знову помножуються на sign, 
# щоб відновити їхні оригінальні значення.


import heapq

def heap_sort(iterable, descending=False):
    # Визначаємо, який знак використовувати залежно від порядку сортування
    sign = -1 if descending else 1

		# Створюємо купу, використовуючи заданий порядок сортування
    h = [sign * el for el in iterable]
    heapq.heapify(h)
    # Витягуємо елементи, відновлюємо їхні оригінальні значення (якщо потрібно) і формуємо відсортований масив
    return [sign * heapq.heappop(h) for _ in range(len(h))]

# Приклади використання функції
arr = [12, 11, 13, 5, 6, 7]
# Сортування за зростанням (за замовчуванням)
sorted_arr_asc = heap_sort(arr)
print("Відсортований масив (за зростанням):", sorted_arr_asc)
# Сортування за спаданням
sorted_arr_desc = heap_sort(arr, descending=True)
print("Відсортований масив (за спаданням):", sorted_arr_desc)


# Відсортований масив (за зростанням): [5, 6, 7, 11, 12, 13]
# Відсортований масив (за спаданням): [13, 12, 11, 7, 6, 5]

