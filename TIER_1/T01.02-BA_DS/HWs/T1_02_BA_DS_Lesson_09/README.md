## Benchmark (Greedy vs DP)

Coins: `[50, 25, 10, 5, 2, 1]`  
Metric: seconds per call (min of 5 runs), number=200

| Amount | Greedy (s/call) | Greedy Fast (s/call)  | Greedy Slow (s/call)  | DP (s/call) |
|------:|-----------------:|----------------------:|----------------------:|------------:|
| 113   | 0.00000088       | 0.00000089            | 0.00000194            | 0.00017477  |
| 1000  | 0.00000084       | 0.00000039            | 0.00000259            | 0.00202908  |
| 5000  | 0.00000058       | 0.00000026            | 0.00001051            | 0.01024259  |

### Conclusion
- Жадібний алгоритм має часову складність **O(m)** на один виклик, де `m` — кількість номіналів монет.
- Динамічне програмування (ДП) має часову складність **O(m * A)** на один виклик і пам’ять **O(m * A)**, де `A` — сума.
- Для великих сум ДП стає значно повільнішим, бо обсяг роботи зростає лінійно з `A`, але воно гарантує мінімальну кількість монет для будь-якого набору номіналів.
- Жадібний алгоритм працює швидше, але для деяких систем монет може давати не оптимальний результат, бо робить локально найкращий вибір (бере найбільшу доступну монету), який не завжди приводить до глобально мінімальної кількості монет.

**Приклад, де greedy не оптимальний:**  
монети `[10, 6, 1]`, сума `12`  
- greedy: `10 + 1 + 1` (3 монети)  
- оптимально (ДП): `6 + 6` (2 монети)
