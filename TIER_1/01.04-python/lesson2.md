# translate() and str.maketrans()

# TRANSLATE
intab = "aeiou"
outtab = "12345"
trantab = str.maketrans(intab, outtab)

str = "This is string example"
print(str.translate(trantab))
# Th3s 3s str3ng 2x1mpl2


intab = "aeiou"
trantab = str.maketrans('', '', intab)
str = "This is string example"
print(str.translate(trantab))
# Ths s strng xmpl

1. intab = "aeiou"
Это строка со всеми гласными буквами английского алфавита.
То есть мы говорим:
“Вот набор символов, которые я хочу удалить из текста.”

2. str.maketrans('', '', intab)
str.maketrans() создаёт таблицу перевода символов — специальный объект, который говорит translate(), что делать с каждым символом.
Формат вызова:
str.maketrans(from, to, delete)
from — символы, которые нужно заменить,
to — на что заменить (по позициям),
delete — символы, которые нужно удалить.

3. Что делает .translate(trantab)
Метод .translate() применяет созданную таблицу к строке и:
удаляет (или заменяет) символы, согласно таблице.




# шестнадцатеричные символы (0–F) в двоичный код (0000–1111)
symbols = "0123456789ABCDEF"
code = [
        '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
        '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'
        ]
symbols- строка, содержащая символы, которые будут преобразовываться.
code- список строк с двоичным кодом, соответствующий каждому символу в symbols.

В данном конкретном случае использование str.maketrans() для создания
таблицы перевода не будет такой же эффективной, как вручную созданная таблица перевода. Для создания таблицы мы используем словарь MAP. Для этого мы используем zip(symbols, code), который создает пары символ двоичный код.
Далее цикл for проходит по этим парам, добавляя в MAPсоответствие между Unicode кодом символа с помощью функции ord(s) и его двоичным кодом c. Для каждого символа прилагается как его верхний, так и нижний регистр s.lower().

MAP = {}
for s ,  c in zip(symbols , code):
    MAP[ ord (s)] =  c 
    MAP[ ord (s.lower())] =  c

# Функция zip() объединяет эти два списка парами:
('0', '0000')
('1', '0001')
('2', '0010')
...
('F', '1111')

# Что делает ord(s):
ord('A') → 65
ord('0') → 48
Это числовой код символа (в Unicode).
То есть Python строит таблицу, где ключ — числовой код символа, а значение — двоичное представление.

{
     48 : "0000" ,
     49 : "0001" , 50
     : " 0010
     " ,
     51 : "0011 " ,
     52 : "0100" , 53
     : " 0101 " ,
     54 : " 0110 " ,
     50 : ,
     57 : " 1001 " ,
     65 : " 1010 " ,
     97 : " 1010
     " ,
     66 : " 1011
     " ,
     98 :
     "
     1011 "​​​​​​ ,
     69 : "1110" ,
     101 : "1110" ,
     70 : "1111" ,
     102 : "1111 "
}

# Замена символов через .translate()
result = "34 DF 56 AC".translate(MAP)
print(result)
.translate(MAP) идёт по каждому символу строки и:
если символ есть в MAP, заменяет его на двоичный код;
если нет — оставляет как есть (например, пробел).

# !!!!! Коротко: str.translate заменяет только те символы, для которых в таблице есть ключ.
Все остальные символы «пропускаются» и выводятся как есть. Отсюда ощущение, что «некоторых символов нет».

Где ключ это Unicode для символов "0123456789ABCDEF"в верхнем и нижнем регистре, а значение соответствующих элементов списка code.

result = "34 DF 56 AC" .translate( MAP )
 print ( result )
00110100 11011111  01010110  10101100





# Преобразование ключей словаря в коды Unicode
morze_dict = { 'A' : '.-' , 'B' : '-...' , 'C' : '-.-.' , 'D' : '-..' , 'E' : '.' , 'F' : '..-.' ,
               'G' : '--.' , 'H' : '....' , 'I' : '..' , 'J' : '.---' , 'K' : '-.-' , 'L' : '.-..' ,
               'M' : '--' , 'N' : '-.' , 'O' : '---' , 'P' : '.--.' , 'Q' : '--.-' , 'R' : '.-.' ,
               'S' : ' ... ' , 'T' : ' - ' , ' U ' : ' ..- ' , ' V ' : ' ...- ' , ' W ' : .
               : '-----' , '1' : '.----' , '2' : '..---' ,
               '3' : '...--' , ' 4' : '....-' , '5' : '.....' , '6' : ' -.... ' ,
               '' ' ' ' '---..' , '9' : '----.' }


table_morze_dict = {}
for k, v in morze_dict.items():
    table_morze_dict[ord(k)] = v

# ord(k) — превращает букву в её числовой Unicode-код.
# (например, ord('A') == 65)

# Почему именно k и v?
# Потому что это просто короткие имена:
# k от key — ключ,
# v от value — значение.
# Ты можешь назвать как угодно: for letter, morze_code in morze_dict.items():

string = "Hello world"

result = ""

for ch in  string :
    result=result+ch. upper ().translate(table_morze_dict)

# Что здесь происходит:
1. ch.upper() — переводим букву в верхний регистр ('h' → 'H'),
потому что в словаре Морзе только заглавные.
2. .translate(table_morze_dict) — заменяет символ на его код Морзе,
если он есть в словаре.
3. result = result + ... — добавляет результат в итоговую строку.

print (result)
......-...-..--- .-----.-..-..-..






# ФОРМАТИРОВАНИЕ СТРОК
for i in range( 8 ):
    s = f "int: {i:d}; hex: {i: #x }; oct: {i: #o }; bin: {i: #b }" 
    print (s)
int: 0 ; hex: 0x0 ; oct: 0o0 ; bin: 0b0 
int: 1 ; hex: 0x1 ; oct: 0o1 ; bin: 0b1 
int: 2 ; hex: 0x2 ; oct: 0o2 ; bin: 0b10 
int: 3 ; hex: 0x3 ; oct: 0o3 ; bin: 0b11 
int: 4 ; hex: 0x4 ; oct: 0o4 ; bin: 0b100 
int: 5 ; hex: 0x5 ; oct: 0o5 ; bin: 0b101 
int: 6 ; hex: 0x6 ; oct: 0o6 ; bin: 0b110 
int: 7 ; hex: 0x7 ; oct: 0o7 ; bin: 0b111



price  =  19.99 
quantity  =  3 
total  = f "Total: {price * quantity:.2f}"
print(total)
Total : 59 . 97
# В этом примере используется форматирование :.2f для отображения действительного числа с двумя цифрами после десятичного разделителя.
В выражении :.2f 
: вводит спецификацию формата.
.2 означает, что после десятичной точки должно быть выведено две цифры.
f указывает формат действительного числа.




# печать таблицы чисел, из квадратов и кубов, красиво выровненную по центру.
width = 5 
for num in range( 12 ):
     print (f'{num:^ 10 } {num** 2 :^ 10 } {num** 3 :^ 10 }')
   0         0         0     
   1         1         1     
   2         4         8     
   3         9         27    
   4         16        64    
   5         25       125    
   6         36       216    
   7         49       343    
   8         64       512    
   9         81       729    
   10       100       1000   
   11       121       ​

1. for num in range(12):
    Значит: перебираем num от 0 до 11 (всего 12 чисел).
2. num**2 и num**3
    num**2 — это num во второй степени, то есть квадрат числа
    2**2 = 4, 3**2 = 9, 4**2 = 16
    num**3 — это куб числа
    2**3 = 8, 3**3 = 27, 4**3 = 64
3. f-строка f'{num:^10}'
    : — начало инструкции форматирования
    ^ — значит выровнять по центру
    10 — ширина поля (10 символов)
    f'{num:^10}' - это «запиши num, но оставь вокруг него столько пробелов, чтобы всего заняло 10 позиций, и выровняй по центру».
4. Выравнивание определяет, как содержимое выравнивается внутри указанной ширины поля.      Возможные варианты выравнивания:
    <: Выравнивание содержимого по левому краю.
    >: Выравнивание содержимого по правому краю.
    ^: Выравнивание содержимого по центру.
    =: Используется для выравнивания чисел, при этом знак (если он есть) отображается слева, а число – по правому краю поля.





name = "Alice" 
formatted = f "{name:>10}" 
print(formatted)   # Выведет: 'Alice' (выравнивание вправо)
     Alice




f"{value: <ширина> . <точность> %}"
где:
    value– значение, которое нужно превратить в проценты.
    <ширина>- общая ширина поля; необязательно.
    <точність>- количество знаков после десятичной точки; необязательно.



completion = 0 . 756 
formatted = f "{completion:.1%}" 
print (formatted) # Выведет: ' 75 . 6 %'
75 . 6 %


progress = 0.5 
formatted = f"{progress:.0%}" 
print(formatted)
50 %


