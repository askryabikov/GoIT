    
--------РАБОТА С ТЕКСТОВЫМИ ФАЙЛАМИ


    open(file, mode = 'r' , buffering =-1, encoding =None, errors =None, newline =None, closefd = True , opener =None)

Параметры:

1. file – путь к файлу в виде строки. Это может быть полный путь или путь относительно текущего каталога исполнения.
2. mode(необязательный) – режим, в котором будет открыт файл. 
    Вот основные режимы, которые мы будем использовать:
    'r'- чтение (по умолчанию). Файл должен существовать;
    'w'- запись. Создает новый файл или перезаписывает уже существующий файл;
    'a'- сложение. Дописывает в конец файла, не перезаписывая его;
    'b'- бинарный режим (может использоваться вместе с другими, например 'rb'или 'wb');
    'r+' - чтение и добавление новой информмации в конец строки
    'w+' - удаляет содержание файла, если оно существует
    'x' - открыввает только новые файлы
    '+'- обновление (чтение и запись).
3. buffering(необязательный) – определяет буферизацию: 
    0 - для выключенной;
    1 - для включенной буферизации строк;
    больше 1 - для указания размера буфера в байтах.
4. encoding(необязательный) – имя кодирования, которое будет использоваться для кодирования или декодирования файла.
5. errors(необязательный) – указывает, как обрабатывать ошибки кодирования.
6. newline(необязательный) – контролирует, как обрабатываются новые строки.
7. closefd(необязательный) – должно быть True (по умолчанию); 
    Если указано False - файловый дескриптор не будет закрыт.
8. opener(необязательный) – определяет специальную функцию для открытия файла.




    fh = open ( 'test.txt' , 'w' ) 
    symbols_written = fh. write ( 'hello!' ) 
    print(symbols_written) #6 
    fh. close ()
В этом примере мы создали (или перезаписали, если он уже существовал) файл test.txt для записи и записали строку  'hello!' длиной 6символов. Для записи данных в файл мы использовали метод  write у объекта  fh. Этот метод возвращает количество записанных в файл символов – в нашем случае число 6.



    fh = open ( 'test.txt' , 'w+' ) 
    fh. write ( 'hello!' ) 
    fh. seek ( 0 ) 
    first_two_symbols = fh. read ( 2 ) 
    print(first_two_symbols)   # 'he'
    fh. close ()
В этом примере мы открыли файл в режиме чтения и записи, но сам файл мы перезаписываем, если он существует, потому что используется режим w+. Записали в файл строку 'hello!' и прочли первые два символа из файла с помощью метода read, указав в качестве аргумента двойку. Метод read возвращает прочтенные символы и поскольку мы прочитали 2 символа, то переменная first_two_symbols будет сохранять строку "he". Чтобы вернуть указатель к началу файла, мы вызвали метод seek и передали ему позицию, куда нужно переместиться 0. 




fh = open ( 'test.txt' , 'w' ) 
fh. write ( 'hello!' ) 
fh. close () 

fh = open ( 'test.txt' , 'r' )
 while True: 
    symbol = fh. read ( 1 )  # читает один символ из файла
     if  len (symbol) == 0 : # проверяет ни вернулась ли пустая строка
         break    # если файл прочитан до конца - цикл прерывается
    print (symbol) 

fh. close ()
Пока файловый дескриптор не закрыт, вы можете читать с него по частям, продолжая чтение с того же места, на котором остановились.
! while True - бесконечный цикл, который работает пока его не прервут



    READLINE
fh = open ( 'test.txt' , 'w' ) 
fh. write ( 'first line\nsecond line\nthird line' ) 
fh. close () 

fh = open ( 'test.txt' , 'r' )
 while True:
     line = fh.readline()
     и не line :
         break 
    print ( line ) 

fh. close ()

first  line 
second  line 
third  line
В цикле while True выполняется непрерывное чтение из файла. Метод readline()читает одну строчку из файла за раз. Если readline()возвращает пустую строку, это означает, что достигнут конец файла, поэтому цикл прерывается с помощью break. Каждая прочитанная строка выводится на экран. Поскольку readline()сохраняет символы перехода на новую строку, каждая выводимая строка будет выведена из новой строки.




    ЧТЕНИЕ СТРОКИ
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
lines = fh.readlines()
print(lines)

fh.close()
['first line\n', 'second line\n', 'third line']



    ЧТЕНИЕ СТРОКИ 
fh = open("test.txt", "w")
fh.write("first line\nsecond line\nthird line")
fh.close()

fh = open("test.txt", "r")
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()
['first line', 'second line', 'third line']
Здесь мы для удаления символа переноса строки \n использовали метод strip()и теперь вывод у нас чистый.




    SEEK
    УПРАВЛЕНИЕ КУРСОРОМ
fh = open ( 'test.txt' , 'w+' ) 
fh. write ( 'hello!' ) 

fh. seek ( 1 )
 second = fh. read ( 1 ) 
print( second )   # 'e'
 
fh. close ()
В этом примере после записи в файл курсор будет остановлен на последнем символе. В выражении  fh.seek(1) мы переместили курсор на второй символ файла. Перемещение курсора можно перезаписывать символы файла или читать записанное.

Метод  seek может принимать опционально второй аргумент, указывающий, откуда нужно считать смещение. По умолчанию смещение задается с самого начала файла, но можно задать с конца или из текущего положения. К сожалению, указание смещения с конца файла не на всех платформах поддерживается и лучше использовать вариант по умолчанию.




    TELL
    ПОЛОЖЕНИЕ КУРСОРА
fh = open("test.txt", "w+")
fh.write("hello!")

position = fh.tell()
print(position)  # 6

fh.seek(1)
position = fh.tell()
print(position)  # 1

fh.read(2)
position = fh.tell()
print(position)  # 3

fh.close()
6
1
3
Чтобы узнать положение курсора в этот момент, можно воспользоваться методом  tell, он возвращает позицию (номер) символа из начала файла, где находится курсор.




--------МЕНЕДЖЕР КОНТЕКСТА

fh = open ( 'text.txt' , 'w' )
 try :
     # Выполнение операций с файлом 
    fh. write ( 'Some data' )
 finally :
     # Закрытие файла в блоке finally гарантирует, что файл закроется даже в случае ошибки 
    fh. close ()



ПО-ДРУГОМУ, НО ЛУЧШЕ:
with  open ( 'text.txt' , 'w' ) as fh:
     # Выполнение операций с файлом 
    fh. write ( 'Some data' )
# Файл автоматически закроется после выхода из блока with
С точки зрения работы, этот пример делает в точности то же, что и предыдущий с блоком  try ... finally. Но вместо пяти строк кода, вы можете написать две, и код выглядит более читабельным. Здесь withавтоматически обеспечивается закрытие файла, даже если возникает ошибка внутри блока кода. Это делает код не только более чистым, но и более безопасным, поскольку снижает риск забыть закрыть файл.




with open("test.txt", "w") as fh:
    fh.write("first line\nsecond line\nthird line")

with open("test.txt", "r") as fh:
    lines = [el.strip() for el in fh.readlines()]

print(lines)
# ['first line', 'second line', 'third line']











--------РАБОТА С НЕТЕКСТОВЫМИ ФАЙЛАМИ
Если же необходимо работать не с текстовыми файлами, то можно указать режим открытия файлов как b, сокращенно от  bytes. В таком режиме вы получите файловый объект для работы с файлом в режиме байт строк.

with  open ( 'raw_data.bin' , 'wb' ) as fh:
    fh. write (b 'Hello world!' )
1. мы открываем файл raw_data.bin для записи (w) и говорим, что будем записывать бинарные (сырые) данные (b).
То есть — не обычный текст, а байты.
2. b'Hello world!' - буква b перед строкой показывает, что это байтовая строка.
Например:
'H' (текст) → b'H' (байт).
3. fh.write(b'Hello world!') — записывает эти байты в файл.
4. with ... as fh: — специальная конструкция, которая автоматически закрывает файл, даже если произойдёт ошибка.
То есть не нужно писать fh.close() вручную.
5. Зачем нужен режим 'wb':
'w' — записывает текст (строки).
'wb' — записывает байты (например, картинки, звук, файлы программ).

Чтобы работать с последовательностью байтов в Python есть встроенные типы данных байт-строков:
bytes- неизменный тип, используемый для представления байтов.
bytearray- сменный тип, позволяющий модифицировать байты после их создания.




СОЗДАНИЕ БАЙТ-СТРОК
byte_string =b 'Hello world!'
В этом примере  byte_string содержит последовательность символов по одному байту на каждого. От объявления обычной строки байт-строка отличает наличие символа  b в начале строки.


ENCODE
ПРЕОБРАЗОВАНИЕ В БАЙТ-СТРОКУ:
byte_str = 'some text'.encode()
print(byte_str)
# В byte_str будет записана последовательность байтов b'some text'


str.encode( encoding = "utf-8" , errors = "strict" )
encoding- указывает метод кодировки. По умолчанию используется 'utf-8', поддерживающий большое количество символов из разных языков.
    - errors– указывает, как обрабатывать ошибки кодирования. Например, 'strict'для выброса исключения в случае ошибки, 
    - 'ignore'для игнорирования ошибок или: 
    - 'replace'для замены невозможных кодировок символов на определенный заменитель




ПРЕОБРАЗОВАНИЕ СПИСКА ЧИСЕЛ В БАЙТ-СТРОКУ
numbers = [ 0 , 128 , 255 ]
 byte_numbers = bytes(numbers)
 print( byte_numbers)  # Выведет байтовое представление чисел
# b' \x 00 \x 80 \x ff'
- Символ \x является индикатором шестнадцатеричной записи каждого байта.



HEX
Чтобы проверить правильность представления, можно воспользоваться встроенной функцией  hex, которая преобразует целое число в строку:
for num in [127, 255, 156] :
   print ( hex (num))
0x7f 
0xff 
0x9c



ORD
CHR
--------КОДИРОВКИ
ord ( 'a' )  
# 97
Чтобы узнать, какому элементу в UTF-8 соответствует символ, есть функция  ord (от order).


chr ( 128 )  
# 'd'
Обратная операция, когда нужно узнать, какой символ закодирован числом, например 100, есть функция  chr (сокращенно от character):




s = "Привет!"
 
utf8 = s .encode ()
 print (f "UTF-8: {utf8}" )
 
utf16 = s .encode ( "utf-16" )
 print 
( f " UTF-16: {utf16}" ) 
cp1251 = s .encode ( " cp1251 " )
 {cp1251}" ) 
s_from_utf16 = utf16 .decode ( "utf-16" )
 print (s_from_utf16 == s)

UTF -8 : b' \x d0 \x 9f \x d1 \x 80 \x d0 \x b8 \x d0 \x b2 \x d1 \x 96 \x d1 \x 82!' 
UTF- 16 : b' \x ff \x fe \x 1f \x 04@ \x 048 \x 042 \x 04V \x 04B \x 04! \x 00' 
CP- 1251 : b' \x cf \x f0 \x e8 \x e2 \x b3 \x f2!' 
True



РЕКОМЕНДАЦИЯ ОТКРЫВАТЬ С УКАЗАНИЕМ UTF-8
# Открытие текстового файла с явным указаниям UTF-8 кодирования 
with  open ( 'example.txt' , 'r' , encoding= 'utf-8' ) as  file : 
    content= file . read () 
    print(content)





--------МАССИВЫ БАЙТОВ
bytearray — это изменяемая версия байт-строки.
byte_array = bytearray(b'Kill Bill')
byte_array[0] = ord('B')
byte_array[5] = ord('K')
print(byte_array)

bytearray(b'Bill Kill')

1. создаётся массив байтов из строки 'Kill Bill'.
Он похож на список чисел, где каждый символ — это число от 0 до 255 (его ASCII-код).
'K' = 75, 'i' = 105, 'l' = 108, 'l' = 108, ...
2. ord('B') возвращает числовой код буквы 'B' (в ASCII это 66).
Мы заменяем первый байт (букву K) на B.
3. заменяем шестой символ (букву B) на K.


| Тип         | Можно менять? | Что хранит            | Пример                |
| ----------- | ------------- | --------------------  | --------------------- |
| `bytes`     | ❌ Нет        | Байты (неизменяемые) | `b'Hello'`            |
| `bytearray` | ✅ Да         | Байты (изменяемые)   | `bytearray(b'Hello')` |



APPEND
Кроме изменения существующих элементов bytearrayпозволяет добавлять и удалять элементы
byte_array = bytearray ( b "Hello" ) 
byte_array.append ( ord ( "!" ))  
 print ( byte_array )
bytearray (b 'Hello!' )


DECODE
byte_array = bytearray(b "Hello World" )    
 string = byte_array.decode( "utf-8" ) 
print( string ) 
Hello World




