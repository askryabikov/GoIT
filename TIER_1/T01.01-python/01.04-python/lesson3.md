

# REGULAR EXPRESSIONS
Основные функции модуля reкоторые мы рассмотрим далее:
re.search(pattern, string)- выполняет поиск первого вхождения шаблона в строке.
re.findall(pattern, string)- выполняет нахождение всех вхождений шаблона в строке.
re.sub(pattern, repl, string)- выполняет замену вхождений шаблона на другую строку.
re.split(pattern, string)производит разбивание строки по шаблону.

Регулярные выражения используют специальные символы для создания шаблонов. Они состоят из блоков и модификаторов.

# Примером блока может служить:
\w- любая цифра или буква [a-zA-Z0-9_]( \W- все, кроме буквы или цифры [^a-za-z0-9_])
\d- любая цифра [0-9]( \D- все, кроме цифры [^0-9])
\s- любой пробельный символ [\t\n\r\f\v]( \S- все, кроме пробельных символов [^\t\n\r\f\v])
\b- предел слова
[...]- один из символов в скобках ( [^ ]- любой символ, кроме тех, что в скобках)
^и $— начало и конец строки соответственно
( )- группирует выражение и возвращает найденный текст
\t, \n, \r— символ табуляции, новой строки и возвращения каретки


# Модификаторы могут указывать на количество повторений блока в выражении, например:
.- один любой символ, кроме строки\n
?— 0или 1вхождение шаблона слева
+— 1и больше вхождений шаблона слева
*— 0и больше вхождений шаблона слева
\- экранирование спец.символов (пример: \.- означает точку или \+- знак "плюс")
{n} строго  n раз ( n целое число)
{n,m}- от nдо mвхождений (пример: {,m}- от 0до m)
a|b— отвечает aили b. Сам символ |означает "или" между двумя шаблонами
( )- группирует выражение и возвращает найденный текст



import re - Стандартный модуль в python

# SEARCH
re.search()используется для поиска первого вхождения шаблона в строке

re .search ( pattern , string)
    pattern: Регулярное выражение (шаблон), которое вы хотите найти
    string: Строка, в которой вы хотите найти шаблон.

# MATCH
Объект Matchобладает свойствами и методами, используемыми для получения информации о поиске и результатах:
    Match.span() возвращает кортеж, содержащий начальную и конечную позиции совпадения.
    Match.string возвращает строку, передаваемую в функцию,
    Match.group() возвращает часть строки, в которой было совпадение

import re
text = "Изучение Python может быть веселым." 
pattern = "Python" 
match = re.search(pattern, text )
if  match :
     print ( "Найдено:" , match . group ())
 else :
     print ( "Не найдено." )
# Найдено: Python




import re
text = "Моя електронна адреса: example@example.com"
pattern = r"\w+@\w+\.\w+"
match = re.search(pattern, text)
if match:
    print("Електронна адреса:", match.group())
# Електронна адреса: example@example.com


У цьому прикладі регулярний вираз \w+@\w+\.\w+ шукає електронну адресу:
1. \w+ - спочатку повинні йти одна або більше букв або цифр.
2. @ - далі обов'язково повинен бути символ @.
3. \w+ - після символу @ повинна йти ще одна серія букв.
4. \. - серія букв повинна закінчитись символом крапки. Ми екрануємо його, бо в регулярному виразі, крапка є модифікатором та має спеціальне значення.
5. \w+ - далі йде серія букв після крапки.




import re

email = "username@domain.com"
pattern = r"(\w+)@(\w+\.\w+)"
match = re.search(pattern, email)

if match:
    user_name = match.group(1)
    domain_name = match.group(2)
    print("Ім'я користувача:", user_name)
    print("Домен:", domain_name)

Ім'я користувача: username
Домен: domain.com

RE: (\w+)@(\w+\.\w+). 
1. Перші круглі дужки (\w+) відповідають одному або більше словесним символам. Це група збігається з ім'ям користувача електронної адреси. 
2. Далі в нас відбувається пошук @ - символ, що розділяє ім'я користувача та домен. Він нам не потрібний і в дужки ми його не беремо. 
3. Другі круглі дужки (\w+\.\w+) відповідають за домену електронної адреси. Тут \w+ збігається з першою частиною домену, \. - це крапка, і ще один \w+ для збігу з доменом верхнього рівня (наприклад, "com").
4. Коли re.search() знаходить відповідність, вона повертає об'єкт Match. Методи match.group(1) та match.group(2) використовуються для вилучення тексту, що відповідає кожній групі в шаблоні.




# FINDALL

import re
matches = re.findall(pattern, string)
    pattern- регулярное выражение, которое вы ищете.
    string- строка, в которой нужно найти соответствия.



import re 
text = "Год 2023 был сложнее, чем 2022" 
pattern = r"\d+" 
matches = re .
# [ '2023 ', '2022 ']

1. В этом примере регулярное выражение \d+ищет одну или более цифр в строке подряд и находит их, на выходе мы получаем список всех чисел в строке.



Необходимо произвести выборку всех слов в тексте. Здесь пригодится использование такого регулярного выражения \w+для нахождения всех слов в строке. Мы использовали блок \w, любую цифру или букву и модификатор +, это 1и больше вхождений шаблона слева, нам нужны слова в которых есть хоть одна буква:

import re 
text = "Python - это простой, но мощный язык программирования." 
pattern = r"\w+" 
matches = re.findall(pattern, text) print (matches)   # Выведет список всех слов в строке
# [ 'Python ', 'это ', 'простой ', 'но ', 'мощный ', 'язык ', 'программирования ']
# Регулярное выражение \w+ отвечает за любую последовательность букв, цифр или подчеркиваний,




пример нахождения электронных адресов:

import re 
text = 
" Контакты: example1@example.com, example2@sample.org" pattern 
= r"\w+@\w+\.\w + "  
# [ 'example1@example.com ', 'example2@sample.org ']




# SUB
Метод re.sub()в модуле rePython используется для замены вхождений регулярного выражения patternв строке stringна строку repl.

import re 
modified_string = re.sub(pattern, repl, string )

    pattern- регулярное выражение, указывающее часть строки, которую нужно заменить.
    repl- строка, на которую будут заменены совпадения.
    string- строка, в которой происходит замена.




У нас есть название файла с пробелами, например "Мій документ Python.txt". Нам нужно превратить это название так, чтобы вместо пробелов были подчеркивания, получая "Мій_документ_Python.txt".

import re 
file_name = "Мой документ Python.txt" 
pattern = r"\s" 
replacement = "_" 
formatted_name = re.sub(pattern, replacement, file_name) print (formatted_name)  
# Мой_документ_Python.txt
В этом примере блок \s соответствует любому пробелу и он заменяется на _.




Удалите все пунктуационные знаки из строки

import re 
text = "Python - мощный, универсальный; язык!" 
pattern = r"[;,\-:!\.]" 
replacement = "" 
modified_text = re.sub(pattern, replacement, text )  
print(modified_text)  
# Python   мощный универсальный язык

Здесь регулярное выражение [;,\-:!\.]– это набор (множественное число) символов, включающий различные пунктуационные знаки. 





В тексте у нас телефоны записаны в таком формате 050-171-1634, нам необходимо заменить их на формат(050) 171-1634
import re

phone = """
        Михайло Куліш: 050-171-1634
        Вікторія Кущ: 063-134-1729
        Оксана Гавриленко: 068-234-5612
        """
pattern = r"(\d{3})-(\d{3})-(\d{4})"
replacement = r"(\1) \2-\3"
formatted_phone = re.sub(pattern, replacement, phone)
print(formatted_phone)
# Михайло Куліш: (050) 171-1634
# Вікторія Кущ: (063) 134-1729
# Оксана Гавриленко: (068) 234-5612

1. В этом примере регулярное выражение (\d{3})-(\d{3})-(\d{4}) ищет номера в формате XXX-XXX-XXXX. 
2. Каждая группа чисел ( \d{3}или \d{4}) помещена в круглые скобки для сохранения в группах. 
3. В строке replacement мы обращаемся к этим найденным группам \1, \2, \3 и они соответствуют первой, второй и третьей группе соответственно. 
4. Мы говорим, что первую группу, например, нужно поместить в круглые скобки. Далее пробел и между группами оставить дефис.





# SPLIT
Функция re.split()в модуле rePython используется для разбивания строки по заданному регулярному выражению. Это позволяет разделять текст на части по более сложным критериям, чем простой строчный метод split().

import re 
list_of_elements = re.split(pattern, string )
    pattern- регулярное выражение, используемое в качестве разделителя.
    string- строка, которую нужно разделить.



import re 
text = "Python - это простой, но мощный язык программирования." 
pattern = r"\s+" 
words = re.split(pattern, text) print (words)   # Выведет список слов в строке
# [ 'Python ', '- ', 'это ', 'простая ', 'но ', 'мощная ', 'язык ', 'программирование. ']

В этом примере \s+ соответствует одному или более пробольным символам (пробел, табуляция и т.п.). И вывод будет как у обычного метода split():




Попробуем разделить строку на части, используя пунктуационные знаки в качестве разделителей:
import re 
text = "Python - мощный; простой, универсальный: язык!" 
pattern = r"[;,\-:!\s]+" 
elements = re.split(pattern, text) print (elements)  
# Выведет список частей, разделенных пунктуацией
# [ 'Python ', 'мощный ', 'простой ', 'универсальный ', 'язык ', '']

1. регулярное выражение [;,\-:!\s]+ совпадает с любой последовательностью одного или более символов из набора ;, ,, -, :, !или любого пробела. 
2. Благодаря квантификатору + последовательность разделителей рассматривается как один разделитель, помогающий избежать создания пустых строк в результате вывода.





Раздел строки по шаблону, содержащий несколько возможных разделителей:
import re 
text = "apple#banana!mango@orange;kiwi" 
pattern = r"[#@;!]" 
fruits = re.split(pattern, text) print (fruits)
# [ 'apple ', 'banana ', 'mango ', 'orange ', 'kiwi ']

В этом примере [#@;!] создается набор символов, включающий #, @, ;, и !, каждый из которых может быть использован в качестве разделителя. И мы получаем список с фруктами:




